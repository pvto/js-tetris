<!DOCTYPE html>
<html lang="fi">
<meta charset="UTF-8">
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />

<script src="lib/d3.js"></script>
<script src="lib/lodash.js"></script>
<script src="lib/arr2.js"></script>
<link href='https://fonts.googleapis.com/css?family=Montserrat:700' rel='stylesheet' type='text/css'>

<style>
#game-container {
  font-family: 'Montserrat', sans-serif;
  text-align: center;
}
</style>

<!-- Montserrat font -->
<script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Montserrat:700:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })(); </script>


<!-- Tetris -->
<div id="game-container">
</div>

<script type="text/javascript">
(function (){
  var wwdt = window.innerWidth;
  var whgt = window.innerHeight;
  console.log(wwdt + " " + whgt);
  var xdim = 14;
  var ydim = 20;
  var block = Math.min(wwdt * 0.9 / xdim, whgt * 0.9 / ydim);

  var margin = { top: block * 1, bottom: 0, left: 0, right: 0 };
  var width = block * xdim - margin.left - margin.right;
  var height = block * ydim - margin.top - margin.bottom;
  var gameCanvas = d3.select("#game-container")
    .append("canvas")
    .attr("id", "game-canvas")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .text("Sorry, your browser does not support HTML5 Canvas.")
    .node();
  var baseTransform = function(context) {
    context.setTransform(1, 0, 0, 1, margin.left, margin.top);
  };
  var FONT = "'Montserrat', sans-serif";

  var pieces = {
    'J': { y0: -1,
        p:
          [[' ',' ',' '],
          ['A',' ',' '],
          ['A','A','A']] },
    'L': { y0: -1,
        p:
          [[' ',' ',' '],
          ['C',' ',' '],
          ['C','C','C']] },
    'O': { y0: 0,
        p:
          [['B','B'],
          ['B','B']] },
    'T': { y0: 0,
        p:
          [[' ','C',' '],
          ['C','C','C'],
          [' ',' ',' ']] },
    'I': { y0: 0,
        p:
          [[' ',' ','D',' '],
          [' ',' ','D',' '],
          [' ',' ','D',' '],
          [' ',' ','D',' ']] },
    'Z': { y0: 0,
        p:
          [['A','A',' '],
          [' ','A','A'],
          [' ',' ',' ']]},
    'S': { y0: 0,
        p:
          [[' ','C','C'],
          ['C','C',' '],
          [' ',' ',' ']]}
  };
  var bgSpace = arr2fill(arr2(xdim, ydim), '.');
  var space = arr2fill(arr2(xdim, ydim), ' ');

  var randomPiece = function() {
    var keys = _.keys(pieces);
    var x = Math.floor(Math.random() * keys.length);
    return _.cloneDeep(pieces[keys[x]]);
  };
  var initActivePiece = function(a, piece) {
    a.piece = piece;
    a.x = xdim / 2 - Math.floor(piece.p[0].length / 2),
    a.y = piece.y0
  };
  var timeZero = new Date().getTime();
  var activePiece = {
    redraw: true, score: 0, level: 0,
    timer: timeZero,
    borrow: 0
  };
  BLOCK_SCORE = [0, 40, 100, 300, 1200];
  var scoreMessage = { x: width - block*0.5, y: block*1.5,
    text: function() { return activePiece.score + ""; },
    font: "20px " + FONT, fill: "#00e000", xalign: -1 };
  var levelMessage = { x: block*0.5, y: block*1.5,
    text: function() { return "LEVEL " + activePiece.level;},
    font: "20px " + FONT, fill: "#0000e0", xalign: 1 };
  var messages = [ scoreMessage, levelMessage ];

  initActivePiece(activePiece, randomPiece());

  var paste = function(to, u, v, src) {
      arr2paste(to, u, v, src, ' ');
  };

  var drawBg0 = function(context, tick, xx, yy, ww, hh) {
    context.fillStyle = "#FFFFFF";
    context.fillRect(xx, yy, ww, hh);
  };
  var drawBg1 = function(context, tick, xx, yy, ww, hh, c, u, v) {
    var x = xx+ww/20,
      y = yy+hh/20,
      w = ww*18/20,
      h = hh*18/20
      ;
    if (c == ".") {
      context.translate(x+w/2,y+h/2);
      if (11 == (u*ydim+v) % 12) {
        context.rotate(tick * 2 * Math.PI / 100000 % (2*Math.PI));
      }
      context.fillStyle = "#EEEEEE";
      var f = 4;
      context.fillRect(-w/2+w/f/2, -h/2+h/f/2, w*(f-2)/f, h*(f-2)/f*2);
      baseTransform(context);
    }
  };

  var fillTwoRects = function(context, xx, yy, ww, hh, cola, scalea, colb, scaleb) {
    var x = xx+ww/scalea,
      y = yy+hh/scalea,
      w = ww*(scalea-2)/scalea,
      h = hh*(scalea-2)/scalea
      ;
      context.fillStyle = cola;
      context.fillRect(x, y, w, h);
      context.fillStyle = colb;
      context.fillRect(x + w/scaleb, y + h/scaleb, w*(scaleb-2)/scaleb, h*(scaleb-2)/scaleb);
  };
  var drawPiece = function(context, tick, xx, yy, ww, hh, c) {
    if (c == "A") {
      fillTwoRects(context, xx, yy, ww, hh,
        "#000060", 80, "#6040A0", 10);
    }
    else if (c == "B") {
      fillTwoRects(context, xx, yy, ww, hh,
        "#6060F0", 80, "#C0C0F0", 10);
    }
    else if (c == "C") {
      fillTwoRects(context, xx, yy, ww, hh,
        "#A0A0F0", 80, "#202020", 4);
    }
    else if (c == "D") {
      fillTwoRects(context, xx, yy, ww, hh,
        "#D0D0D0", 80, "#FFFFFF", 4);
    }
  };
  var drawBoardAt = (function() {
    var ret = function(canvas, tick) {
      var context = canvas.getContext("2d");
      baseTransform(context);
      var pieceWidth = width / xdim;
      var pieceHeight = height / ydim;
      for(var x = 0; x < xdim; x++) {
        for(var y = -1; y < ydim; y++) {
          drawBg0(context, tick, x * pieceWidth, y * pieceHeight, pieceWidth, pieceHeight);
        }
      }
      for(var x = 0; x < xdim; x++) {
        for(var y = 0; y < ydim; y++) {
          var c = bgSpace[y][x];
          drawBg1(context, tick, x * pieceWidth, y * pieceHeight, pieceWidth, pieceHeight, c, x, y);
        }
      }
      for(var x = 0; x < xdim; x++) {
        for(var y = 0; y < ydim; y++) {
          var c = space[y][x];
          drawPiece(context, tick, x * pieceWidth, y * pieceHeight, pieceWidth, pieceHeight, c);
        }
      }
      for(var y = 0; y < activePiece.piece.p.length; y++) {
        for(var x = 0; x < activePiece.piece.p[y].length; x++) {
          var c = activePiece.piece.p[y][x];
          drawPiece(context, tick,
            (x + activePiece.x) * pieceWidth,
            (y + activePiece.y) * pieceHeight,
            pieceWidth, pieceHeight, c);
        }
      }

      messages.forEach(function(message, i) {
        if (message.end && tick > message.end) {
          var index = messages.indexOf(message);
          messages.splice(index, 1);
        }
      });
      messages.forEach(function(message, i) {
        if (!message.start || message.start < tick) {
          drawMessage(context, tick, message);
        }
      });
    };
    return ret;
  })();

  var drawBoard = function() {
    drawBoardAt(gameCanvas, new Date().getTime());
  };

  var drawMessage = function(context, tick, message) {
    var font = message.font
        || (block*xdim * 1.5 / (message.text.length + 1)) + "px " + FONT;
    context.font = font;
    var text = _.isFunction(message.text) ? message.text() : message.text;
    var measurex = context.measureText(text);
    message.drawx = message.x + measurex.width * (((message.xalign||0.0)-1)/2);
    context.fillStyle = message.fill || "#4080B0";
    context.fillText(text, message.drawx, message.y);
  };

  var addNotifyMessage = function(text, delay, duration, message) {
    var start = new Date().getTime() + (delay || 0);
    var message = message || {};
    message.text = text;
    message.start = start;
    message.end = start + (duration || 1000);
    message.x = message.x || block * xdim / 2;
    message.y = message.y || block * ydim /4;
    messages.push(message);
  };

  var dropOne = function() {
    var count = 0;
    if (!testCrash({y:activePiece.y + 1, x:activePiece.x}, activePiece.piece.p)) {
      activePiece.y++;
      count++;
    } else {
      renew();
    }
    activePiece.redraw = true;
    return count;
  };

  var renew = function() {
    if (activePiece.gameOver === true) {
      return;
    }
    paste(space, activePiece.x, activePiece.y, activePiece.piece.p);
    destroyFullRows();
    initActivePiece(activePiece, randomPiece());
    if (testCrash({y:activePiece.y, x:activePiece.x}, activePiece.piece.p)) {
      gameOver();
    }
  };

  var destroyFullRows = function() {
    var n = 0;
    for(var y = ydim - 1; y >= 0; y--) {
      var full = true;
      for(var x = 0; x < xdim; x++) {
        if (space[y][x] == ' ') {
          full = false;
        }
      }
      if (full) {
        space.splice(y, 1);
        space.unshift(arr2(xdim, ydim)[0]);
        drawBoard();
        y++;
        n++;
      }
    }
    if (n != 0) {
      var increment = BLOCK_SCORE[n] * (activePiece.level + 1);
      if (xdim * ydim === arr2contains(space, ' ')) {
        increment *= 4;
        for(var tt = 0; tt < 1200; tt += 400) {
          addNotifyMessage("4x points", tt, 200);
          addNotifyMessage("4x POINTS", tt+200, 200);
        }
      }
      if (n == 4) {
        addNotifyMessage("" + increment, 200, 800, { y: block * ydim / 6})
      }
      incrementScore(increment);
    }
  };

  var testCrash = function(xy, p) {
    var crash = false;
    for(var y = 0; y < p.length; y++) {
      for(var x = 0; x < p[y].length; x++) {
        if (0 > xy.y + y) {
          if (' ' != p[y][x] &&
              (xy.x + x < 0 || xy.x + x >= space[0].length)) {
            return true;
          }
        }
        if (' ' != p[y][x] && 0 <= xy.y + y) {
          if (space.length - 1 < y + xy.y) {
            return true;
          }
          if (' ' != space[xy.y + y][xy.x + x]) {
            return true;
          }
        }
      }
    }
    return false;
  };
  var incrementScore = function(amount) {
    activePiece.score += amount;
    scoreMessage.text = activePiece.score + "";
    incrementLevel();
  };

  var incrementLevel = function() {
    var requiredPoints = 3000 * (activePiece.level + 1);
    if (activePiece.score > requiredPoints) {
      activePiece.level++;
    }
  };

  var gameOver = function() {
    if (activePiece,gameOver === true) { return; }
    activePiece.gameOver = true;
    var text = "Done!";
    console.log(text);
    messages.push({
      text: text,
      y: block * (ydim * 2 / 3),
      x: block * (xdim / 2),
      fill: "#000000",
      font: (block*xdim * 1.5 / (text.length + 1)) + "px " + FONT
    });
    while (testCrash({y:activePiece.y, x:activePiece.x}, activePiece.piece.p)) {
      activePiece.y--;
    };
    drawBoard();
    activePiece.redraw = true;
  };
  var rotateWithsideLineBorrow = function(tmp) {
    if (!testCrash({y:activePiece.y, x:activePiece.x + activePiece.borrow}, tmp)) {
      activePiece.piece.p = tmp;
      activePiece.x += activePiece.borrow;
      activePiece.borrow = 0;
    } else if (activePiece.borrow !== 0
      && (!testCrash({y:activePiece.y, x:activePiece.x}, tmp))) {
      activePiece.piece.p = tmp;
    } else {
      if (activePiece.x < 0) {
        if (!testCrash({y:activePiece.y, x:activePiece.x + 1}, tmp)) {
          activePiece.x++;
          activePiece.borrow = -1;
          activePiece.piece.p = tmp;
        }
      } else if (activePiece.x + activePiece.piece.p[0].length >= xdim) {
        if (!testCrash({y:activePiece.y, x:activePiece.x - 1}, tmp)) {
          activePiece.x--;
          activePiece.borrow = 1;
          activePiece.piece.p = tmp;
        }
      }
    }
  };
  var doSlideX = function(xadd) {
    if (!testCrash({y:activePiece.y, x:activePiece.x + xadd}, activePiece.piece.p)) {
      activePiece.x += xadd;
    }
  };
  var doRotCw = function() {
    var tmp = rcw(activePiece.piece.p);
    rotateWithsideLineBorrow(tmp);
  };
  var doRotCcw = function() {
    var tmp = rccw(activePiece.piece.p);
    rotateWithsideLineBorrow(tmp);
  };
  var doDropOne = function() {
    incrementScore(dropOne());
  };
  var doDropMany = function() {
    while (!testCrash({y:activePiece.y + 1, x:activePiece.x}, activePiece.piece.p)) {
      activePiece.y++;
      incrementScore(2)
      drawBoard();
    }
    renew();
  };

  document.onkeydown = function(event) {
    activePiece.redraw = true;

    if (activePiece.gameOver === true) {
      return;
    }
    if (37 == event.keyCode) { doSlideX(-1); }
    else if (39 == event.keyCode) { doSlideX(1); }
    else if (38 == event.keyCode || 34 == event.keyCode) {
      doRotCw(); }
    else if (33 == event.keyCode) { doRotCcw(); }
    else if (40 == event.keyCode) { doDropOne(); }
    else if (32 == event.keyCode) { doDropMany(); }
  };


  var parentReduceSum = function(node, f) {
    var sum = 0;
    while (node) {
      sum += (f(node) || 0);
      node = node.parentNode;
    }
    return sum;
  };

  document.onclick = function(event) {
    activePiece.redraw = true;

    if (activePiece.gameOver === true) {
      return;
    }

    var node = document.getElementById("game-canvas");
    var offsetLeft = parentReduceSum(node, function(node) { return node.offsetLeft; });
    var offsetTop = parentReduceSum(node, function(node) { return node.offsetTop; });
    var xleft = offsetLeft + (activePiece.x) * block;
    var xright = offsetLeft + (activePiece.x + activePiece.piece.p[0].length) * block;
    var ytop = offsetTop + (activePiece.y) * block;
    var ybottom = offsetTop + (activePiece.y + activePiece.piece.p.length) * block;
    console.log(event);

    var margin = 10;
    if (event.clientX < xleft - margin) { doSlideX(-1); }
    else if (event.clientX > xright + margin) { doSlideX(1); }
    else {
      if (event.clientY > ybottom + margin) {
        if (event.detail == 2) { doDropMany(); }
        else { doDropOne(); }
      }
      else if (event.clientY > ytop - margin) { doRotCw(); }
      else { doRotCcw(); }
    }
  }

  var checkRedraw = function() {
    var timed = false;
    messages.forEach(function(message, i) {
      if (message.end) {
        timed = true;
      }
    });
    if (timed === false) {
      activePiece.redraw = false;
    }
  };

  var drawThread = function() {
    var now = new Date().getTime();
    if (now > activePiece.timer + 1000 / (activePiece.level + 1)) {
      dropOne();
      activePiece.timer = now;
    }
    if (activePiece.redraw) {
      drawBoard();
      checkRedraw();
    }
    window.setTimeout(drawThread, 25);
  };
  drawThread();

  var createInput = function(text, action) {
    var action0 = function() {
      d3.event.preventDefault();
      activePiece.redraw = true;
      if (activePiece.gameOver === true) {
        return;
      }
      action();
    };
    d3.select("#game-controls").append("button")
      .attr("type", "button")
      .text(text)
      .on("click", action0)
      .style("width", (width / 7) + "px")
      .style("height", (width / 10) + "px");
  };
  d3.select("#game-container").append("div").attr("id", "game-controls");
  createInput("↖", doRotCcw);
  createInput("↗", doRotCw);
  createInput("←", function(){ doSlideX(-1); });
  createInput("↓", doDropOne);
  createInput("→", function(){ doSlideX(1); });
  createInput("_", doDropMany);

})();
</script>

</html>
